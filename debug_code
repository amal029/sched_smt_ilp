
       (* if counter > 1 then *)
       (* 	 let ov = Z3.ast_to_string ctx oval in *)
       (* 	 let ov = get_values ov in *)
       (* 	 if (ov -. !lower_bound > 1.0) then *)
       (* 	   begin *)
       (* 	     lower_bound := ov; 	(\* move the lower bound *\) *)
       (* 	   end *)
       (* 	 else raise Internal_error *)
       (* else *)
       (*   let () = Z3.solver_pop ctx solver 1 in *)
       (*   let () = print_endline (" MMMM: " ^ string_of_int (Z3.solver_get_num_scopes ctx solver)) in *)
       (*   let () = IFDEF TDEBUG THEN print_endline (Z3.ast_vector_to_string ctx (Z3.solver_get_assertions ctx solver)) ELSE () ENDIF in  *)
       (*   let _ = Z3.solver_check ctx solver in (\* this should always succeed *\) *)
       (*   let mmodel = Z3.solver_get_model ctx solver in *)
       (*   let () = if model then (Z3.model_to_string ctx mmodel) |> print_endline else () in *)
       (*   let mm = Z3.mk_func_decl ctx (Z3.mk_string_symbol ctx "M") [||] (Z3.mk_real_sort ctx) in *)
       (*   let mval = (match Z3.model_get_const_interp ctx mmodel mm with  *)
       (* 	       | None -> raise (Solver_error "Could not find M's value in solver!")  *)
       (* 	       | Some s -> s) in  *)
       (*   let mv = Z3.ast_to_string ctx mval in *)
       (*   print_endline ("Optimal M with reduce: " ^ (string_of_float ((get_values mv)) ^ "," ^ (string_of_float 1.0))) *)
       (* else  *)
       (* It did not succeed even the first time!! *)
